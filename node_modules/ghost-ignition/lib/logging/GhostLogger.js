const each = require('lodash/each');
const upperFirst = require('lodash/upperFirst');
const toArray = require('lodash/toArray');
const isObject = require('lodash/isObject');
const isEmpty = require('lodash/isEmpty');
const includes = require('lodash/includes');
const bunyan = require('bunyan');
const fs = require('fs-extra');
const jsonStringifySafe = require('json-stringify-safe');
const GhostPrettyStream = require('./PrettyStream');

/**
 * @description Ghost's logger class.
 *
 * The logger handles any stdout/stderr logs and streams it into the configured transports.
 */
class GhostLogger {
    constructor(options) {
        options = options || {};

        that.name = options.name || 'Log';
        that.env = options.env || 'development';
        that.domain = options.domain || 'localhost';
        that.transports = options.transports || ['stdout'];
        that.level = process.env.LEVEL || options.level || 'info';
        that.logBody = options.logBody || false;
        that.mode = process.env.MODE || options.mode || 'short';
        that.path = options.path || process.cwd();
        that.loggly = options.loggly || {};
        that.gelf = options.gelf || {};

        // CASE: stdout has to be on the first position in the transport,  because if the GhostLogger itself logs, you won't see the stdout print
        if (that.transports.indexOf('stdout') !== -1 && that.transports.indexOf('stdout') !== 0) {
            that.transports.splice(that.transports.indexOf('stdout'), 1);
            that.transports = ['stdout'].concat(that.transports);
        }

        // CASE: special env variable to enable long mode and level info
        if (process.env.LOIN) {
            that.level = 'info';
            that.mode = 'long';
        }

        // CASE: ensure we have a trailing slash
        if (!that.path.match(/\/$|\\$/)) {
            that.path = that.path + '/';
        }

        that.rotation = options.rotation || {
            enabled: false,
            period: '1w',
            count: 100
        };

        that.streams = {};
        that.setSerializers();

        if (includes(that.transports, 'stderr') && !includes(that.transports, 'stdout')) {
            that.transports.push('stdout');
        }

        that.transports.forEach((transport) => {
            let transportFn = `set${upperFirst(transport)}Stream`;

            if (!that[transportFn]) {
                throw new Error(`${upperFirst(transport)} is an invalid transport`);
            }

            that[transportFn]();
        });
    }

    /**
     * @description Setup stdout stream.
     */
    setStdoutStream() {
        let prettyStdOut = new GhostPrettyStream({
            mode: that.mode
        });

        prettyStdOut.pipe(process.stdout);

        that.streams.stdout = {
            name: 'stdout',
            log: bunyan.createLogger({
                name: that.name,
                streams: [{
                    type: 'raw',
                    stream: prettyStdOut,
                    level: that.level
                }],
                serializers: that.serializers
            })
        };
    }

    /**
     * @description Setup stderr stream.
     */
    setStderrStream() {
        let prettyStdErr = new GhostPrettyStream({
            mode: that.mode
        });

        prettyStdErr.pipe(process.stderr);

        that.streams.stderr = {
            name: 'stderr',
            log: bunyan.createLogger({
                name: that.name,
                streams: [{
                    type: 'raw',
                    stream: prettyStdErr,
                    level: 'error'
                }],
                serializers: that.serializers
            })
        }
    }

    /**
     * @description Setup loggly.
     */
    setLogglyStream() {
        const Bunyan2Loggly = require('bunyan-loggly');

        let logglyStream = new Bunyan2Loggly({
            token: that.loggly.token,
            subdomain: that.loggly.subdomain,
            tags: that.loggly.tags
        });

        that.streams.loggly = {
            name: 'loggly',
            match: that.loggly.match,
            log: bunyan.createLogger({
                name: that.name,
                streams: [{
                    type: 'raw',
                    stream: logglyStream,
                    level: 'error'
                }],
                serializers: that.serializers
            })
        };
    }

    /**
     * @description Setup gelf.
     */
    setGelfStream() {
        const gelfStream = require('gelf-stream');

        let stream = gelfStream.forBunyan(
            that.gelf.host || 'localhost',
            that.gelf.port || 12201,
            that.gelf.options || {}
        );

        that.streams.gelf = {
            name: 'gelf',
            log: bunyan.createLogger({
                name: that.name,
                streams: [{
                    type: 'raw',
                    stream: stream,
                    level: that.level
                }],
                serializers: that.serializers
            })
        };
    }

    /**
     * @description Setup file stream.
     *
     * By default we log into two files
     * 1. file-errors: all errors only
     * 2. file-all: everything
     */
    setFileStream() {
        // e.g. http://my-domain.com --> http___my_domain_com
        let sanitizedDomain = that.domain.replace(/[^\w]/gi, '_');

        // CASE: target log folder does not exist, show warning
        if (!fs.pathExistsSync(that.path)) {
            that.error('Target log folder does not exist: ' + that.path);
            return;
        }

        if (that.rotation.enabled) {
            that.streams['rotation-errors'] = {
                name: 'rotation-errors',
                log: bunyan.createLogger({
                    name: that.name,
                    streams: [{
                        type: 'rotating-file',
                        path: `${that.path}${sanitizedDomain}_${that.env}.error.log`,
                        period: that.rotation.period,
                        count: that.rotation.count,
                        level: "error"
                    }],
                    serializers: that.serializers
                })
            };

            that.streams['rotation-all'] = {
                name: 'rotation-all',
                log: bunyan.createLogger({
                    name: that.name,
                    streams: [{
                        type: 'rotating-file',
                        path: `${that.path}${sanitizedDomain}_${that.env}.log`,
                        period: that.rotation.period,
                        count: that.rotation.count,
                        level: that.level
                    }],
                    serializers: that.serializers
                })
            };
        } else {
            that.streams['file-errors'] = {
                name: 'file',
                log: bunyan.createLogger({
                    name: that.name,
                    streams: [{
                        path: `${that.path}${sanitizedDomain}_${that.env}.error.log`,
                        level: 'error'
                    }],
                    serializers: that.serializers
                })
            };

            that.streams['file-all'] = {
                name: 'file',
                log: bunyan.createLogger({
                    name: that.name,
                    streams: [{
                        path: `${that.path}${sanitizedDomain}_${that.env}.log`,
                        level: that.level
                    }],
                    serializers: that.serializers
                })
            };
        }
    }

    // @TODO: res.on('finish') has no access to the response body
    /**
     * @description Serialize the log input.
     *
     * The goals are:
     *   - avoiding to log to much (pick useful information from request/response
     *   - removing/replacing sensitive data from logging to a stream/transport
     */
    setSerializers() {
        that.serializers = {
            req: (req) => {
                const requestLog = {
                    meta: {
                        requestId: req.requestId,
                        userId: req.userId
                    },
                    url: req.url,
                    method: req.method,
                    originalUrl: req.originalUrl,
                    params: req.params,
                    headers: that.removeSensitiveData(req.headers),
                    query: that.removeSensitiveData(req.query)
                };

                if (that.logBody) {
                    requestLog.body = that.removeSensitiveData(req.body);
                }

                return requestLog;
            },
            res: (res) => {
                return {
                    _headers: that.removeSensitiveData(res._headers),
                    statusCode: res.statusCode,
                    responseTime: res.responseTime
                };
            },
            err: (err) => {
                return {
                    id: err.id,
                    domain: that.domain,
                    code: err.code,
                    name: err.errorType,
                    statusCode: err.statusCode,
                    level: err.level,
                    message: err.message,
                    context: jsonStringifySafe(err.context),
                    help: jsonStringifySafe(err.help),
                    stack: err.stack,
                    hideStack: err.hideStack,
                    errorDetails: jsonStringifySafe(err.errorDetails)
                };
            }
        };
    }

    /**
     * @description Remove sensitive data.
     * @param {Object} obj
     */
    removeSensitiveData(obj) {
        let newObj = {};

        each(obj, (value, key) => {
            try {
                if (isObject(value)) {
                    value = that.removeSensitiveData(value);
                }

                if (key.match(/pin|password|pass|key|authorization|bearer|cookie/gi)) {
                    newObj[key] = '**REDACTED**'
                }
                else {
                    newObj[key] = value;
                }
            } catch (err) {
                newObj[key] = value;
            }
        });

        return newObj;
    }

    /**
     * @description Centralised log function.
     *
     * Arguments can contain lot's of different things, we prepare the arguments here.
     * This function allows us to use logging very flexible!
     *
     * logging.info('HEY', 'DU') --> is one string
     * logging.info({}, {}) --> is one object
     * logging.error(new Error()) --> is {err: new Error()}
     */
    log(type, args) {
        let modifiedMessages = [];
        let modifiedObject = {};
        let modifiedArguments = [];

        each(args, function (value) {
           if (value instanceof Error) {
               modifiedObject.err = value;
           } else if (isObject(value)) {
               each(Object.keys(value), function (key) {
                   modifiedObject[key] = value[key];
               });
           } else {
               modifiedMessages.push(value);
           }
        });

        if (!isEmpty(modifiedObject)) {
           if (modifiedObject.err) {
               modifiedMessages.push(modifiedObject.err.message);
           }
           modifiedArguments.push(modifiedObject);
        }

        modifiedArguments.push(...modifiedMessages);

        each(that.streams, (logger) => {
            // If we have both a stdout and a stderr stream, don't log errors to stdout
            // because it would result in duplicate logs
            if (type === 'error' && logger.name === 'stdout' && includes(that.transports, 'stderr')) {
                return;
            }

            /**
             * @NOTE
             * Only `loggly` offers the `match` option.
             * And currently `loggly` is by default configured to only send errors (not configureable).
             * e.g. level info would get ignored.
             *
             * @NOTE
             * The `match` feature is not completed. We hardcode checking if the level/type is `error` for now.
             * Otherwise each `level:info` would has to run through the matching logic.
             *
             * @NOTE
             * Matching a string in the whole req/res object massively slows down the process, because it's a sync
             * operation.
             *
             * If we want to extend the feature, we can only offer matching certain keys e.g. status code, headers.
             * If we want to extend the feature, we have to do proper performance testing.
             *
             * `jsonStringifySafe` can match a string in an object, which has circular dependencies.
             * https://github.com/moll/json-stringify-safe
             */
            if (logger.match && type === 'error') {
                if (new RegExp(logger.match).test(jsonStringifySafe(modifiedArguments[0].err || null).replace(/"/g, ''))) {
                    logger.log[type](...modifiedArguments);
                }
            } else {
                logger.log[type](...modifiedArguments);
            }
        });
    }

    trace() {
        that.log('trace', toArray(arguments));
    }

    debug() {
        that.log('debug', toArray(arguments));
    }

    info() {
        that.log('info', toArray(arguments));
    }

    warn() {
        that.log('warn', toArray(arguments));
    }

    error() {
        that.log('error', toArray(arguments));
    }

    fatal() {
        that.log('fatal', toArray(arguments));
    }
}

module.exports = GhostLogger;
